gds <- fread(paste0(base_url, "data/Geriatric_Depression_Scale__Short_.csv"))
# the questions represented by the above columns have inverted values, i.e a "no" answer counts as a point towards depression whereas a "yes" does not
gds[, c(4, 8, 10, 14, 16)] <- 1 - gds[, c(4, 8, 10, 14, 16)]
# codelist did not contain any relevant information as far as I can tell
gds$gds_score <- gds_solution(gds_form = gds)
# reverting the values of the above columns to what they were originally
gds[, c(4, 8, 10, 14, 16)] <- 1 - gds[, c(4, 8, 10, 14, 16)]
gds
code_book <- fread(paste0(base_url, "decoding/Code_List.csv"))
data_dict <- fread(paste0(base_url,"decoding/Data_Dictionary.csv"))
# load demographics and primary diagnosis tables
demo <- fread(paste0(base_url,"data/Screening___Demographics.csv"))
diag <- fread(paste0(base_url, "data/Primary_Diagnosis.csv"))
discrepency_solution <- function(demo, diag){
demo <- subset(demo, select = c(PATNO, APPRDX))
diag <- subset(diag, select = c(PATNO, PRIMDIAG))
joint <- as.data.table(na.omit(full_join(demo, diag, by = 'PATNO', keep = T)))
mismatch <- joint[APPRDX == "2" & PRIMDIAG != "17" | APPRDX != "2" & PRIMDIAG == "17"]
# Consider expanding this to make it more generalizable - look more carefully at the
# study document and figure out which APPRDX corresponds to which PRIMDIAG, and what
# that means re: inclusion/exclusion criteria - Everything non-PD is just neuro disorder
return(mismatch)
}
sec2 <- discrepency_solution(demo, diag)
sec2
# Combine all three tables (GDS, Demographics, and Diagnosis information) into a single table.
combined_solution <- function(gds, demo, diag, sec2) {
# Turn all scores to booleans
gds <- gds %>% mutate_at(c(4:18), as.logical)
# Replace NAs with 0s
demo[is.na(demo)] <- 0
# Drop all rows where PT either declined inclusion or was excluded for any reason
# Also drop any rows with discrepency found in section 2
demo <- subset(demo, DECLINED == 0 & EXCLUDED == 0) %>%
subset(.,!PATNO == sec2$PATNO)
# Join the three tables
return(full_join(full_join(gds, demo, by = "PATNO"), diag, by = "PATNO"))
}
combined_solution(gds, demo, diag, sec2)
library(data.table)
library(tidyverse)
base_url <- "http://data.blackfynn.io/curator_data_challenge/"
# "0" answers are a point towards depression for columns 4, 8, 10, 14, 16
gds_score <- function(gds_form) {
return(rowSums(subset(gds_form, select = 4:18)))
}
gds_solution <- function(gds_form){
return(gds_score(gds_form))
}
# each column is a question in the gds-short, each row is a pt. 0 and 1 represent their yes/no answers
gds <- fread(paste0(base_url, "data/Geriatric_Depression_Scale__Short_.csv"))
# the questions represented by the above columns have inverted values, i.e a "no" answer counts as a point towards depression whereas a "yes" does not
gds[, c(4, 8, 10, 14, 16)] <- 1 - gds[, c(4, 8, 10, 14, 16)]
# codelist did not contain any relevant information as far as I can tell
gds$gds_score <- gds_solution(gds_form = gds)
# reverting the values of the above columns to what they were originally
gds[, c(4, 8, 10, 14, 16)] <- 1 - gds[, c(4, 8, 10, 14, 16)]
gds
code_book <- fread(paste0(base_url, "decoding/Code_List.csv"))
data_dict <- fread(paste0(base_url,"decoding/Data_Dictionary.csv"))
# load demographics and primary diagnosis tables
demo <- fread(paste0(base_url,"data/Screening___Demographics.csv"))
diag <- fread(paste0(base_url, "data/Primary_Diagnosis.csv"))
discrepency_solution <- function(demo, diag){
demo <- subset(demo, select = c(PATNO, APPRDX))
diag <- subset(diag, select = c(PATNO, PRIMDIAG))
joint <- as.data.table(na.omit(full_join(demo, diag, by = 'PATNO', keep = T)))
mismatch <- joint[APPRDX == "2" & PRIMDIAG != "17" | APPRDX != "2" & PRIMDIAG == "17"]
# Consider expanding this to make it more generalizable - look more carefully at the
# study document and figure out which APPRDX corresponds to which PRIMDIAG, and what
# that means re: inclusion/exclusion criteria - Everything non-PD is just neuro disorder
return(mismatch)
}
sec2 <- discrepency_solution(demo, diag)
sec2
# Combine all three tables (GDS, Demographics, and Diagnosis information) into a single table.
combined_solution <- function(gds, demo, diag, sec2) {
# Turn all scores to booleans
gds <- gds %>% mutate_at(c(4:18), as.logical)
# Replace NAs with 0s
demo[is.na(demo)] <- 0
# Drop all rows where PT either declined inclusion or was excluded for any reason
# Also drop any rows with discrepency found in section 2
demo <- subset(demo, DECLINED == 0 & EXCLUDED == 0) %>%
subset(.,!PATNO == sec2$PATNO)
# Join the three tables
return(full_join(full_join(gds, demo, by = "PATNO"), diag, by = "PATNO"))
}
combined_solution(gds, demo, diag, sec2)
library(data.table)
library(tidyverse)
base_url <- "http://data.blackfynn.io/curator_data_challenge/"
# Section 1: Calculate a new variable
##################################################################
# "0" answers are a point towards depression for columns 4, 8, 10, 14, 16
gds_score <- function(gds_form) {
return(rowSums(subset(gds_form, select = 4:18)))
}
gds_solution <- function(gds_form){
return(gds_score(gds_form))
}
gds <- fread(paste0(base_url, "data/Geriatric_Depression_Scale__Short_.csv"))
# each column is a question in the gds-short, each row is a pt. 0 and 1 represent their yes/no answers
gds[, c(4, 8, 10, 14, 16)] <- 1 - gds[, c(4, 8, 10, 14, 16)]
# the questions represented by the above columns have inverted values, i.e a "no" answer counts as a point towards depression, and vice versa
# codelist did not contain any relevant information as far as I can tell
gds$gds_score <- gds_solution(gds_form = gds)
gds[, c(4, 8, 10, 14, 16)] <- 1 - gds[, c(4, 8, 10, 14, 16)]
# reverting the values of the above columns to what they were originally
gds
# Section 2: Identify a discrepancy between two tables
##################################################################
code_book <- fread(paste0(base_url, "decoding/Code_List.csv"))
data_dict <- fread(paste0(base_url,"decoding/Data_Dictionary.csv"))
# load demographics and primary diagnosis tables
demo <- fread(paste0(base_url,"data/Screening___Demographics.csv"))
diag <- fread(paste0(base_url, "data/Primary_Diagnosis.csv"))
# PRIMDIAG in diag and APPRDX in demo
# translate APPRDX - 1 = PD and 2 = H (healthy)
# PRIMDIAG - 1 = PD and 17 = H (healthy)
# find where there is a mismatch
discrepency_solution <- function(demo, diag){
demo <- subset(demo, select = c(PATNO, APPRDX))
diag <- subset(diag, select = c(PATNO, PRIMDIAG))
joint <- as.data.table(na.omit(full_join(demo, diag, by = 'PATNO', keep = T)))
mismatch <- joint[APPRDX == "2" & PRIMDIAG != "17" | APPRDX != "2" & PRIMDIAG == "17"]
# Consider expanding this to make it more generalizable - look more carefully at the
# study document and figure out which APPRDX corresponds to which PRIMDIAG, and what
# that means re: inclusion/exclusion criteria - Everything non-PD is just neuro disorder
return(mismatch)
}
sec2 <- discrepency_solution(demo, diag)
sec2
# Section 3: Prepare an "analysis-ready" dataset
##################################################################
# Combine all three tables (GDS, Demographics, and Diagnosis information) into a single table.
combined_solution <- function(gds, demo, diag, sec2) {
# Turn all scores to booleans
gds <- gds %>% mutate_at(c(4:18), as.logical)
# Replace NAs with 0s
demo[is.na(demo)] <- 0
# Drop all rows where PT either declined inclusion or was excluded for any reason
# Also drop any rows with discrepency found in section 2
demo <- subset(demo, DECLINED == 0 & EXCLUDED == 0) %>%
subset(.,!PATNO == sec2$PATNO)
# Join the three tables
return(full_join(full_join(gds, demo, by = "PATNO"), diag, by = "PATNO"))
}
combined_solution(gds, demo, diag, sec2)
Honestly don't know if there is any chance of this paper being published during what could be the worst economic downturn of the century, but might as well go for it.
test <- "Cervix - Ectocervix_intronCounts.txt"
sub("\\_intronCounts.txt.*", "", test)
install.packages("pbmcapply")
library(data.table)
library(GenomicRanges)
library(stringr)
library(annotate)
library(rtracklayer)
library(dplyr)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("mygene")
library(mygene)
test <- fread("results/loosenedRestrictionsGenes.txt")
test
?subset
?select
test <- fread("results/loosenedRestrictionsGenes.txt") %>%
select(., gene_name)
test
res <- queryMany(test, scopes='symbol', fields=c('entrezgene', 'go'), species='human')
res
res
attributes(res)
str(res)
res <- as.data.table(queryMany(test, scopes='symbol', fields=c('entrezgene', 'go'), species='human'))
res
res <- queryMany(test, scopes='symbol', fields=c('entrezgene', 'go'), species='human')
res[1, 'go.MF'][[1]]
res[1, 'go.BP'][[1]]
res[1, 'go.MF'][[1]]
res[1, 'go.CC'][[1]]
res[1,]
res[1,][[1]]
res[2]
res[3]
res[1]
res[1,]
str(res)
str(res)
str(res)
View(res)
res[,go.MF]
res[,"go.MF"]
res[,"go.MF"]
View(res)
head(str(res))
?str
print(str(res), method = "print")
summary(res)
res[[1]]
res[[8]]
rbindlist(res[[1]])
ls()
res <- queryMany(test, scopes='symbol', fields=c('go'), species='human')
library(data.table)
library(GenomicRanges)
library(stringr)
library(annotate)
library(rtracklayer)
library(dplyr)
library(mygene)
test <- fread("results/loosenedRestrictionsGenes.txt") %>%
select(., gene_name)
res <- queryMany(test, scopes='symbol', fields=c('go'), species='human')
View(res)
nrow(test)
test <- fread("results/loosenedRestrictionsGenes.txt")
res <- queryMany(test, scopes='symbol', fields=c('go'), species='human')
test
table(test)
table(test$transcript_id)
duplicate(test)
duplicates(test)
duplicated(test)
duplicated(test)[TRUE]
unique(test)
duplicated(test$transcript_id)
duplicated(test$transcript_id)[TRUE]
res[[1]]
res[[8]]
res[[4]]
res[[3]]
res[[2]]
res[[7]]
res[[6]]
res[[5]]
test
unique(res[[1]])
unique(test$gene_name)
getwd()
library(data.table)
library(GenomicRanges)
library(stringr)
library(annotate)
library(rtracklayer)
library(dplyr)
library(mygene)
test <- fread("results/loosenedRestrictionsGenes.txt")
test
duplicated(test$transcript_id)
getwd()
test2 <- "results/loosenedRestrictions.txt"
test2
test2 <- fread("results/loosenedRestrictions.txt")
test2
test
test$gene_name
as.data.frame(test$gene_name)
as.data.frame(test$gene_name, row.names = F)
as.data.frame(test$gene_name)
?as.data.frame
as.data.frame(test$gene_name, row.names = NULL)
test3 <- as.data.frame(test$gene_name, row.names = NULL)
rownames(test3)
rownames(test3) <- NULL
test3
print(test3, row.names = F)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("RDAVIDWebService")
library(RDAVIDWebService)
?RDAVIDWebService
library(RDAVIDWebService)
library(RDAVIDWebService)
library(data.table)
library(mygene)
library(RDAVIDWebService)
install.packages("rJava")
install.packages("Rtools")
install.packages(c("data.table", "glue", "isoband", "matrixStats", "Rcpp", "RCurl", "reshape2", "stringi", "survival", "tibble", "XML"))
library(RDAVIDWebService)
library(ggplot2)
library(RDAVIDWebService)
library(RDAVIDWebService)
test <- fread("results/loosenedRestrictionsGenes.txt")
library(data.table)
library(mygene)
library(ggplot2)
library(RDAVIDWebService)
test <- fread("results/loosenedRestrictionsGenes.txt")
getwd()
library(data.table)
test <- fread("Stomach.v8.sqtl_signifpairs.txt.gz
test <- fread("Stomach.v8.sqtl_signifpairs.txt.gz)
)
test <- fread("Stomach.v8.sqtl_signifpairs.txt.gz")
test
test <- fread("Whole_Blood_intronCounts.txt")
test
library(RDAVIDWebService)
david <- DAVIDWebService$new(email='aseyedi2@jhu.edu')
david <- RDAVIDWebService$new(email='aseyedi2@jhu.edu')
david <- DAVIDWebService$new(email='arta.seyedian@gmail.com')
david <- DAVIDWebService$new(email='aseyedi2@jhu.edu')
david <- DAVIDWebService$new(email='arta.seyedian@gmail.com')
david <- DAVIDWebService$new(email="arta.seyedian@gmail.com")
david <- DAVIDWebService$new(email="aseyedi2@jhu.edu", url="https://david.ncifcrf.gov/webservice/services/DAVIDWebService.DAVIDWebServiceHttpSoap12Endpoint/")
david
test <- fread("results/loosenedRestrictionsGenes.txt")
library(data.table)
library(mygene)
library(ggplot2)
library(RDAVIDWebService)
test <- fread("results/loosenedRestrictionsGenes.txt")
result <- addList(david, test$gene_name, idType = "OFFICIAL_GENE_SYMBOL", listName = "NL_genes", listType = "Gene")
?addList
str(test$gene_name)
getIdTypes()
getIdTypes(test$gene_name)
getIdTypes(david)
library(biomaRt)
ensembl = useMart("ensembl",dataset="hsapiens_gene_ensembl")
listDatasets(ensembl)
getBM(attributes='hgnc_symbol',
filters = 'ensembl_gene_id',
values = ensemblsIDS,
mart = ensembl)
getBM(attributes='hgnc_symbol',
filters = 'ensembl_gene_id',
values = test$gene_name,
mart = ensembl)
?getBM
getBM(attributes='ensembl_gene_id',
filters = 'hgnc_symbol',
values = test$gene_name,
mart = ensembl)
ensemblIDs <- getBM(attributes='ensembl_gene_id',
filters = 'hgnc_symbol',
values = test$gene_name,
mart = ensembl)
ensembl
ensemblIDs
str(ensemblIDs)
test$gene_name
unique(test$gene_name)
listAttributes()
listAttributes(ensembl)
listFilters(ensembl)
ensemblIDs <- getBM(attributes='ensembl_gene_id',
filters = 'external_gene_name',
values = test$gene_name,
mart = ensembl)
ensemblIDs1 <- getBM(attributes='ensembl_gene_id',
filters = 'hgnc_symbol',
values = test$gene_name,
mart = ensembl)
gene_list <- rtracklayer::import("https://storage.googleapis.com/gtex_analysis_v8/reference/gencode.v26.GRCh38.genes.gtf") %>%
makeGRangesFromDataFrame(., keep.extra.columns = T) %>%
as.data.table()
library(data.table)
library(GenomicRanges)
library(stringr)
library(annotate)
library(rtracklayer)
library(dplyr)
gene_list <- rtracklayer::import("https://storage.googleapis.com/gtex_analysis_v8/reference/gencode.v26.GRCh38.genes.gtf") %>%
makeGRangesFromDataFrame(., keep.extra.columns = T) %>%
as.data.table()
# subset to just protein coding genes
gene_list <- gene_list[type == "gene" & gene_type == "protein_coding"]
gene_list[, subjectHits := .I]
# read coords for NL-specificish introns
# dt <- fread(snakemake@input[["relScripts"]], header = T)
dt <- fread("results/loosenedRestrictions.txt", header = T)
coords <- as.data.table(str_split_fixed(dt$transcript_id, "_", 3))
names(coords) <- c("seqnames", "start", "stop")
coords_gr <- makeGRangesFromDataFrame(coords, keep.extra.columns = F)
gene_list
gene_list_gr <- makeGRangesFromDataFrame(gene_list, keep.extra.columns = T)
# find overlaps like in the top genes script
olaps <- findOverlaps(coords_gr, gene_list_gr) %>%
as.data.table()
olaps
dt[, queryHits := .I]
dt <- dt[olaps, on = "queryHits", nomatch = 0]
dt <- dt[gene_list, on = "subjectHits", nomatch = 0]
dt
?addList
getIdTypes()
getIdTypes(david)
dt <- dplyr::select(dt, c(transcript_id, seqnames, start, end, gene_name, gene_id, n))
write.table(dt,
file = paste0("results/loosenedRestrictionsGenes.txt"),
sep = "\t",
row.names = F,
quote = FALSE)
test <- fread("results/loosenedRestrictionsGenes.txt")
david <- DAVIDWebService$new(email="aseyedi2@jhu.edu", url="https://david.ncifcrf.gov/webservice/services/DAVIDWebService.DAVIDWebServiceHttpSoap12Endpoint/")
test
getIdTypes(david)
result <- addList(david, test$gene_id, idType = "ENSEMBL_GENE_ID", listName = "NL_genes", listType = "Gene")
View(result)
result <- addList(david, test$gene_id, idType = "ENSEMBL_TRANSCRIPT_ID", listName = "NL_genes", listType = "Gene")
View(result)
DT
dt
ary(dplyr)
# use this file which contains information about all of the sequences in hg38
gene_list <- rtracklayer::import("https://storage.googleapis.com/gtex_analysis_v8/reference/gencode.v26.GRCh38.genes.gtf") %>%
# gene_list <- rtracklayer::import(snakemake@input[["gtf"]]) %>%
makeGRangesFromDataFrame(., keep.extra.columns = T) %>%
as.data.table()
# subset to just protein coding genes
gene_list <- gene_list[type == "gene" & gene_type == "protein_coding"]
gene_list[, subjectHits := .I]
# read coords for NL-specificish introns
# dt <- fread(snakemake@input[["relScripts"]], header = T)
dt <- fread("results/loosenedRestrictions.txt", header = T)
coords <- as.data.table(str_split_fixed(dt$transcript_id, "_", 3))
names(coords) <- c("seqnames", "start", "stop")
coords_gr <- makeGRangesFromDataFrame(coords, keep.extra.columns = F)
gene_list_gr <- makeGRangesFromDataFrame(gene_list, keep.extra.columns = T)
# find overlaps like in the top genes script
olaps <- findOverlaps(coords_gr, gene_list_gr) %>%
as.data.table()
dt[, queryHits := .I]
dt <- dt[olaps, on = "queryHits", nomatch = 0]
dt <- dt[gene_list, on = "subjectHits", nomatch = 0]
dt
getIdTypes(david)
test$gene_id
as.data.frame(test$gene_id, row.names = NULL)
print(as.data.frame(test$gene_id))
print(as.data.frame(test$gene_id), row.names = F)
dt
library(data.table)
library(mygene)
library(ggplot2)
library(RDAVIDWebService)
library(biomaRt)
test <- fread("results/loosenedRestrictionsGenes.txt")
test
print(as.data.frame(test$gene_name), row.names = F)
print(as.data.frame(unique(test$gene_name), row.names = F)
)
print(as.data.frame(unique(test$gene_name), row.names = F))
print(as.data.frame(unique(test$gene_name)))
print(as.data.frame(test$gene_name))
print(as.data.frame(test$gene_name), row.names = F)
getwd()
wholeblood <- fread("Whole_Blood_NL_isos.txt")
wholeblood
data("mlmm.gwas.AD")
install.packages("mlmm.gwas")
data("mlmm.gwas.AD")
library("mlmm.gwas")
data("mlmm.gwas.AD")
ei <- fread("entrez_id_conversion.txt")
ei
result <- addList(david, ei$To, idType = "ENSEMBL_TRANSCRIPT_ID", listName = "NL_genes", listType = "Gene")
david <- DAVIDWebService$new(email="aseyedi2@jhu.edu", url="https://david.ncifcrf.gov/webservice/services/DAVIDWebService.DAVIDWebServiceHttpSoap12Endpoint/")
result <- addList(david, ei$To, idType = "ENSEMBL_TRANSCRIPT_ID", listName = "NL_genes", listType = "Gene")
result <- addList(david, ei$To, idType = "ENTREZ_ID", listName = "NL_genes", listType = "Gene")
listidtypes
getIdTypes(david)
result <- addList(david, ei$To, idType = "ENTREZ_GENE_ID", listName = "NL_genes", listType = "Gene")
result
result$inDavid
termCluster<-getClusterReport(david, type="Term")
termCluster
summary(termCluster)
sum(termCluster$mem)
sum(termCluster)
termCluster
str(termCluster)
summary(termCluster)
ei
result
str(result)
david
?getClusterReport
getAllAnnotationCategoryNames(david)
RDAVIDWebService?
?RDAVIDWebService
??RDAVIDWebService
termCluster
str(termCluster)
plot2D(termCluster, 2)
plot2D(termCluster, 1)
plot2D(termCluster, 2)
plot2D(termCluster, 3)
plot2D(termCluster, 2)
getAllAnnotationCategoryNames()
getAllAnnotationCategoryNames(david)
setAnnotationCategories(david, c("GOTERM_BP_ALL", "GOTERM_MF_ALL", "GOTERM_CC_ALL"))
termCluster<-getClusterReport(david, type="Term")
plot2D(termCluster, 2)
plot2D(termCluster, 1)
?plot2D
plot2D(termCluster, 1, names = T, names.genes = T, names.category = T)
plot2D(termCluster, 1, names = T)
plot2D(termCluster, 1)
setAnnotationCategories(david, c("GOTERM_BP_ALL", "GOTERM_MF_ALL"))
termCluster<-getClusterReport(david, type="Term")
plot2D(termCluster, 1)
setAnnotationCategories(david, c("GOTERM_BP_ALL"))
termCluster<-getClusterReport(david, type="Term")
plot2D(termCluster, 1)
plot2D(termCluster, 2)
plot2D(termCluster, 3)
plot2D(termCluster, 1)
